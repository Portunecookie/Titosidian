- Http는 항상 클라이언트가 먼저 요청해야함
- 웹 소켓: 양방향 통신 가능
https://docs.flutter.dev/cookbook/networking/web-sockets
### Stream
- 이 `Stream`클래스는 스트림에서 이벤트를 수동으로 수신하거나, 스트림을 다른 스트림이나 퓨처로 변환할 수 있는 기능도 제공합니다.

- forEach 함수 [는](https://api.flutter.dev/flutter/dart-async/Stream/forEach.html) 루프 에 해당하고 `await for`, [Iterable.forEach는](https://api.flutter.dev/flutter/dart-core/Iterable/forEach.html) 일반 `for`/ `in`루프에 해당합니다. 루프와 마찬가지로 각 데이터 이벤트에 대해 함수를 호출하고 오류가 발생하면 중단합니다.
- 스트림에는 '단일 구독' 스트림과 '브로드캐스트' 스트림의 두 가지 종류가 있습니다.
- _단일 구독 스트림은_ 스트림의 전체 수명 동안 단일 리스너만 허용합니다. 리스너가 있을 때까지 이벤트 생성을 시작하지 않으며, 리스너가 구독 취소되면 이벤트 소스가 더 많은 것을 제공할 수 있더라도 이벤트 전송을 중단합니다. 함수에 의해 생성된 스트림은 `async*`단일 구독 스트림이지만, 함수를 호출할 때마다 새로운 해당 스트림이 생성됩니다.
- 단일 구독 스트림은 일반적으로 파일 I/O와 같은 더 큰 연속 데이터 청크를 스트리밍하는 데 사용됩니다
- _브로드캐스트 스트림은_ 여러 개의 리스너를 허용하며 리스너가 있는지 없는지 여부에 관계없이 리스너가 준비되면 이벤트를 발생시킵니다.
- 일반적인 HTTP 요청 외에도 .을 사용하여 서버에 연결할 수 있습니다 `WebSockets`. `WebSockets`폴링 없이도 서버와 양방향 통신이 가능합니다.


**1. WebSocket**


**장점:**


• **실시간 양방향 통신**: 클라이언트와 서버 간의 빠르고 효율적인 실시간 양방향 통신을 제공합니다.

• **프로토콜 독립적**: 다양한 백엔드 기술과 쉽게 통합할 수 있습니다.

• **낮은 오버헤드**: HTTP 요청/응답 주기를 생략하여 낮은 오버헤드를 가집니다.


**단점:**


• **구현 복잡성**: WebSocket 프로토콜을 직접 구현해야 하므로 상대적으로 복잡합니다.

• **자동 재연결**: 기본적으로 자동 재연결 기능이 없으므로 이를 직접 구현해야 합니다.

• **라이브러리 부족**: Flutter에서 WebSocket을 다루기 위한 다양한 라이브러리나 툴이 적습니다.


**적합한 상황:**


• 간단한 실시간 기능이 필요할 때

• 특정 서버나 서비스와의 통합이 요구될 때

• 사용자 정의가 필요한 복잡한 실시간 통신이 필요할 때

  
**2. Socket.IO**

  
**장점:**


• **높은 추상화**: WebSocket 위에 높은 수준의 추상화를 제공하여 사용하기 쉽습니다.

• **자동 재연결**: 연결이 끊어지면 자동으로 재연결을 시도합니다.

• **다양한 전송 방식**: WebSocket이 지원되지 않는 환경에서는 HTTP Long-Polling 등의 대체 전송 방식을 사용합니다.

• **실시간 이벤트 기반**: 실시간 이벤트 기반 통신을 쉽게 구현할 수 있습니다.

  
**단점:**

  
• **오버헤드**: WebSocket에 비해 상대적으로 높은 오버헤드가 발생할 수 있습니다.

• **서버 요구사항**: 서버에 Socket.IO 서버를 추가로 설정해야 합니다.

• **의존성**: 특정 라이브러리와의 의존성이 생길 수 있습니다.

  
**적합한 상황:**

  
• 복잡한 실시간 기능이 필요할 때

• 자동 재연결 및 다양한 전송 방식을 지원해야 할 때

• 이벤트 기반 통신이 중요한 애플리케이션

  
**3. flutter_socket_io**


**장점:**

  
• **Flutter 통합**: Flutter에서 Socket.IO를 쉽게 사용할 수 있도록 도와줍니다.

• **자동 재연결**: Socket.IO의 자동 재연결 기능을 그대로 사용할 수 있습니다.

• **편리한 이벤트 관리**: 이벤트 기반 통신을 쉽게 관리할 수 있습니다.

  
**단점:**


• **제한된 기능**: Flutter를 위한 Socket.IO 클라이언트의 기능이 제한적일 수 있습니다.

• **의존성**: Socket.IO 서버와의 의존성이 생깁니다.

• **업데이트 문제**: 라이브러리의 업데이트가 원활하지 않을 수 있습니다.

  
**적합한 상황:**

  
• Flutter 앱에서 Socket.IO를 사용하여 실시간 통신을 구현할 때

• 이벤트 기반 통신이 필요한 경우

• 자동 재연결 기능이 중요한 애플리케이션


**4. flutter_chat_ui**


**장점:**

  
• **미리 만들어진 UI 컴포넌트**: 채팅 인터페이스를 빠르게 구현할 수 있는 UI 컴포넌트를 제공합니다.

• **커스터마이징 가능**: 다양한 커스터마이징 옵션을 제공하여 앱의 스타일에 맞게 조정할 수 있습니다.

• **시간 절약**: UI 구현 시간을 크게 절약할 수 있습니다.


**단점:**


• **기능 제한**: 기본 제공 기능 외에 추가 기능을 구현하려면 별도의 작업이 필요합니다.

• **성능**: 매우 복잡하거나 특수한 요구 사항이 있는 경우 성능 문제가 발생할 수 있습니다.

• **종속성**: 특정 UI 구성 요소에 의존하게 됩니다.

  
**적합한 상황:**


• 빠른 시간 내에 채팅 인터페이스를 구현해야 할 때

• 기본적인 채팅 기능이 필요한 경우

• 커스터마이징 가능성이 중요할 때

  
**결론**

  
• **WebSocket**: 서버와 클라이언트 간의 직접적이고 효율적인 실시간 통신이 필요하고, 사용자 정의가 중요한 경우에 적합합니다.

• **Socket.IO**: 복잡한 실시간 기능이 필요하며, 자동 재연결 및 다양한 전송 방식 지원이 중요한 경우에 적합합니다.

• **flutter_socket_io**: Flutter 앱에서 Socket.IO를 사용하여 실시간 이벤트 기반 통신을 쉽게 구현하고자 할 때 적합합니다.

• **flutter_chat_ui**: 빠른 시간 내에 채팅 UI를 구현하고, 커스터마이징 가능한 기본 채팅 인터페이스가 필요할 때 적합합니다.